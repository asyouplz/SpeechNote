import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import { promises as fs } from "fs";
import path from "path";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
Optimized for Phase 4 Performance
*/`;

const prod = (process.argv[2] === "production");
const watch = !prod && process.argv[2] !== "build";
const analyze = process.env.ANALYZE === "true";

// Ensure output directory exists
const outdir = ".";
await fs.mkdir(outdir, { recursive: true });

// Phase 4 ÏµúÏ†ÅÌôî ÏÑ§Ï†ï
const optimizationConfig = {
    // Tree shaking Í∞ïÌôî
    treeShaking: true,
    
    // ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÎäî ÏΩîÎìú Ï†úÍ±∞
    pure: prod ? ["console.log", "console.debug", "console.trace"] : [],
    drop: prod ? ["debugger"] : [],
    
    // Î≤àÎì§ Î∂ÑÏÑùÏö© Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
    metafile: analyze,
    
    // ÏΩîÎìú Ïä§ÌîåÎ¶¨ÌåÖ ÏÑ§Ï†ï
    splitting: false, // Obsidian ÌîåÎü¨Í∑∏Ïù∏ÏùÄ Îã®Ïùº ÌååÏùº ÌïÑÏöî
    
    // ÏµúÏ†ÅÌôî ÌîåÎûòÍ∑∏
    minify: prod,
    minifyWhitespace: prod,
    minifyIdentifiers: prod,
    minifySyntax: prod,
    
    // ÏÜåÏä§Îßµ ÏµúÏ†ÅÌôî
    sourcemap: prod ? false : "inline",
    
    // ÌÉÄÍ≤ü ÏµúÏ†ÅÌôî
    target: "es2018",
    
    // Î≤àÎì§ ÌÅ¨Í∏∞ Í≤ΩÍ≥†
    logLimit: 10
};

const context = await esbuild.context({
    banner: {
        js: banner,
    },
    entryPoints: ["src/main.ts"],
    bundle: true,
    external: [
        "obsidian",
        "electron",
        "@codemirror/autocomplete",
        "@codemirror/collab",
        "@codemirror/commands",
        "@codemirror/language",
        "@codemirror/lint",
        "@codemirror/search",
        "@codemirror/state",
        "@codemirror/view",
        "@lezer/common",
        "@lezer/highlight",
        "@lezer/lr",
        ...builtins
    ],
    format: "cjs",
    outfile: "main.js",
    logLevel: "info",
    
    // Phase 4 ÏµúÏ†ÅÌôî Ï†ÅÏö©
    ...optimizationConfig,
    
    define: {
        'process.env.NODE_ENV': prod ? '"production"' : '"development"',
        'process.env.PERFORMANCE_MONITORING': '"enabled"'
    },
    
    plugins: [
        {
            name: 'clean',
            setup(build) {
                build.onStart(async () => {
                    // Clean previous build artifacts
                    const filesToClean = ['main.js', 'main.js.map', 'meta.json'];
                    for (const file of filesToClean) {
                        try {
                            await fs.unlink(file);
                        } catch (e) {
                            // File doesn't exist, ignore
                        }
                    }
                });
            }
        },
        {
            name: 'bundle-size-checker',
            setup(build) {
                build.onEnd(async (result) => {
                    if (result.errors.length > 0) return;
                    
                    try {
                        const stats = await fs.stat('main.js');
                        const sizeKB = (stats.size / 1024).toFixed(2);
                        const sizeMB = (stats.size / 1024 / 1024).toFixed(2);
                        
                        console.log(`üì¶ Bundle size: ${sizeKB} KB (${sizeMB} MB)`);
                        
                        // Phase 4 Î™©Ìëú: Ï¥àÍ∏∞ Î≤àÎì§ < 150KB
                        const targetSize = 150 * 1024; // 150KB in bytes
                        
                        if (stats.size > targetSize) {
                            console.warn(`‚ö†Ô∏è  Bundle size exceeds target of 150KB!`);
                            console.warn(`   Current: ${sizeKB} KB`);
                            console.warn(`   Target:  150.00 KB`);
                            console.warn(`   Excess:  ${((stats.size - targetSize) / 1024).toFixed(2)} KB`);
                        } else {
                            console.log(`‚úÖ Bundle size is within target (< 150KB)`);
                        }
                        
                        // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù
                        if (analyze && result.metafile) {
                            await fs.writeFile('meta.json', JSON.stringify(result.metafile, null, 2));
                            console.log('üìä Bundle analysis saved to meta.json');
                            
                            // Ï£ºÏöî Î™®Îìà ÌÅ¨Í∏∞ Î∂ÑÏÑù
                            const outputs = result.metafile.outputs;
                            const inputs = result.metafile.inputs;
                            
                            console.log('\nüìà Top 10 largest modules:');
                            const modules = Object.entries(inputs)
                                .map(([path, info]) => ({
                                    path: path.replace('src/', ''),
                                    size: info.bytes
                                }))
                                .sort((a, b) => b.size - a.size)
                                .slice(0, 10);
                            
                            modules.forEach((module, index) => {
                                const sizeKB = (module.size / 1024).toFixed(2);
                                console.log(`   ${index + 1}. ${module.path}: ${sizeKB} KB`);
                            });
                        }
                    } catch (error) {
                        console.error('Failed to check bundle size:', error);
                    }
                });
            }
        },
        {
            name: 'performance-hints',
            setup(build) {
                build.onEnd(result => {
                    if (result.errors.length > 0) {
                        console.error('‚ùå Build failed with errors:');
                        result.errors.forEach(error => {
                            console.error(error);
                        });
                    } else if (result.warnings.length > 0) {
                        console.warn('‚ö†Ô∏è Build succeeded with warnings:');
                        result.warnings.forEach(warning => {
                            console.warn(warning);
                        });
                    } else {
                        const time = new Date().toLocaleTimeString();
                        console.log(`‚úÖ Build succeeded at ${time}`);
                        
                        if (prod) {
                            console.log('\nüí° Performance optimization tips:');
                            console.log('   - Consider lazy loading for non-critical components');
                            console.log('   - Review large dependencies for alternatives');
                            console.log('   - Enable caching for API responses');
                            console.log('   - Monitor runtime memory usage');
                        }
                    }
                });
            }
        }
    ]
});

if (prod) {
    // Production build with optimization report
    console.log('üöÄ Starting optimized production build...');
    await context.rebuild();
    
    // Generate optimization report
    console.log('\nüìã Optimization Report:');
    console.log('   ‚úÖ Tree shaking: Enabled');
    console.log('   ‚úÖ Minification: Enabled');
    console.log('   ‚úÖ Dead code elimination: Enabled');
    console.log('   ‚úÖ Console statements: Removed');
    
    console.log('\nüéØ Phase 4 Performance Targets:');
    console.log('   - Initial bundle: < 150KB');
    console.log('   - Total bundle: < 400KB');
    console.log('   - TTI: < 2 seconds');
    console.log('   - Memory usage: < 50MB');
    
    process.exit(0);
} else if (watch) {
    // Development with watch mode
    console.log("üëÄ Watching for changes with performance monitoring...");
    await context.watch();
} else {
    // Single development build
    await context.rebuild();
    console.log("‚úÖ Development build complete");
    await context.dispose();
}